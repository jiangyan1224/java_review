静态代码块在类加载时调用，是最先执行的，且父类先于子类
然后是父类的普通属性和普通代码块（二者运行顺序取决于在代码中出现的顺序）；父类的构造方法
然后是子类的普通属性和普通代码块（二者运行顺序取决于在代码中出现的顺序）；子类的构造方法
某一属性在声明时初始化，同时在静态/非静态代码块中也初始化，最后结果都是代码块中的值；都是如果是非静态代码块：先执行声明时的初始化，然后执行普通代码块的赋值，最后还是代码块里的值

如果子类定义了和父类类型一样名字一样的private变量，二者相互独立
当子类没有重新定义父类的静态属性，则子类与父类的静态属性是同一个变量
当子类重新定义了父类中的静态属性，子类与父类中的静态属性是两个不同的变量；多态时取什么值，取决于定义的变量类型，也就是左边定义的变量类型（要求父类中对应变量不能是private，否则无法访问）
如果子类父类有完全相同的public/private/protected变量，多态时属性被调用，激活父类属性，隐藏子类属性（也可以说是看左边定义的父类型）

如果父类子类中有完全相同的静态方法，叫方法的隐藏，多态时是执行父类的静态方法，因为静态成员在加载的时候就已经存到静态区了，后面是否创建对象跟它没得关系，  
Fu f = new Zi();  f.method();中，f只是告诉虚拟机f类型时父类，根据一般静态成员的调用方法，所以调用的时父类的静态方法（在idea中,@override会报错，去掉就不会，但是会提醒类方法用类调用）
如果父类子类中相同的对象方法，叫方法的重写override（类实现接口，对接口里的方法也是要重写）。
编译时看左边类里面是否有调用的方法，如果没有编译失败；运行时看右边是否有调用的方法并执行右边对应的方法

子类继承父类，子类就继承了父类的所有方法和属性，但是父类的私有方法和私有属性，子类无法访问/使用

静态方法/代码块只能访问静态变量
非静态方法/代码块可以访问静态/非静态方法

实例化多个对象时，静态代码块时属于类的，只会在一开始执行一次
//////////////////////////
子类实例化时默认调用父类的无参构造函数，如果父类显式写了一个有参没有无参，子类构造函数需要显式调用super(name）进行父类实例化

try-catch-finally:
https://blog.csdn.net/Stduent_/article/details/60955365
1.如果try和finally都有return语句，忽略try的return，使用finally的return
2.就算try中有return，finally语句还是要执行，finally不止为了处理异常，也为了可以在finally里放清理代码，就算没有异常发生也要这样做
3.try里的return，会在把控制权交给该方法的调用者或者构造器之前，执行finally，也就是先finally再return回去
4.如果只有try里面有return：如果有返回值，先把返回值保存到一个局部变量中；然后执行finally里面的语句；最后返回之前保存在局部变量里的值
